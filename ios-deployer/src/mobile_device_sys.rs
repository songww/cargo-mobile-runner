/* automatically generated by rust-bindgen 0.56.0 */

/**
 * Interface to MobileDevice.framework
 *
 * Copied from http://iphonesvn.halifrag.com/svn/iPhone/
 * With modifications from Allen Porter and Scott Turner
 *
 * ------------------------------------------------------------------------- */
use core_foundation::dictionary::{CFDictionaryRef, CFMutableDictionaryRef};
use core_foundation::{
    array::CFArrayRef, base::CFAllocatorRef, string::CFStringRef, url::CFURLRef,
};

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}

/*
#include <mach/error.h>
// Error codes
#define MDERR_APPLE_MOBILE  (err_system(0x3a))
#define MDERR_IPHONE        (err_sub(0))

// Apple Mobile (AM*) errors
#define MDERR_OK                ERR_SUCCESS
#define MDERR_SYSCALL           (ERR_MOBILE_DEVICE | 0x01)
#define MDERR_OUT_OF_MEMORY     (ERR_MOBILE_DEVICE | 0x03)
#define MDERR_QUERY_FAILED      (ERR_MOBILE_DEVICE | 0x04)
#define MDERR_INVALID_ARGUMENT  (ERR_MOBILE_DEVICE | 0x0b)
#define MDERR_DICT_NOT_LOADED   (ERR_MOBILE_DEVICE | 0x25)
*/

// Apple File Connection (AFC*) errors
pub const MDERR_AFC_OUT_OF_MEMORY: u32 = 0x03;

// USBMux errors
pub const MDERR_USBMUX_ARG_NULL: u32 = 0x16; // 22
pub const MDERR_USBMUX_FAILED: u32 = 0xffffffff; // 4294967295

// Messages passed to device notification callbacks: passed as part of
// am_device_notification_callback_info.
pub const ADNCI_MSG_CONNECTED: u32 = 1;
pub const ADNCI_MSG_DISCONNECTED: u32 = 2;
pub const ADNCI_MSG_UNKNOWN: u32 = 3;

pub const AMD_IPHONE_PRODUCT_ID: u32 = 0x1290; // 4752;
pub const AMD_IPHONE_SERIAL: &'static str = "3391002d9c804d105e2c8c7d94fc35b6f3d214a3";

// Services, found in /System/Library/Lockdown/Services.plist
pub const AMSVC_AFC: &str = "com.apple.afc";
pub const AMSVC_BACKUP: &str = "com.apple.mobilebackup";
pub const AMSVC_CRASH_REPORT_COPY: &str = "com.apple.crashreportcopy";
pub const AMSVC_DEBUG_IMAGE_MOUNT: &str = "com.apple.mobile.debug_image_mount";
pub const AMSVC_NOTIFICATION_PROXY: &str = "com.apple.mobile.notification_proxy";
pub const AMSVC_PURPLE_TEST: &str = "com.apple.purpletestr";
pub const AMSVC_SOFTWARE_UPDATE: &str = "com.apple.mobile.software_update";
pub const AMSVC_SYNC: &str = "com.apple.mobilesync";
pub const AMSVC_SCREENSHOT: &str = "com.apple.screenshotr";
pub const AMSVC_SYSLOG_RELAY: &str = "com.apple.syslog_relay";
pub const AMSVC_SYSTEM_PROFILER: &str = "com.apple.mobile.system_profiler";

pub type mach_error_t = ::std::os::raw::c_uint;
pub type afc_error_t = ::std::os::raw::c_uint;
pub type usbmux_error_t = ::std::os::raw::c_uint;

pub type CFSocketNativeHandle = ::std::os::raw::c_int;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct service_conn_t {
    pub unknown: [::std::os::raw::c_char; 16usize],
    pub sockfd: ::std::os::raw::c_int,
    pub sslContext: *mut ::std::ffi::c_void,
}
#[test]
fn bindgen_test_layout_service_conn_t() {
    assert_eq!(
        ::std::mem::size_of::<service_conn_t>(),
        32usize,
        concat!("Size of: ", stringify!(service_conn_t))
    );
    assert_eq!(
        ::std::mem::align_of::<service_conn_t>(),
        8usize,
        concat!("Alignment of ", stringify!(service_conn_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<service_conn_t>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(service_conn_t),
            "::",
            stringify!(unknown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<service_conn_t>())).sockfd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(service_conn_t),
            "::",
            stringify!(sockfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<service_conn_t>())).sslContext as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(service_conn_t),
            "::",
            stringify!(sslContext)
        )
    );
}
pub type ServiceConnRef = *mut service_conn_t;

/* The type of the _AMDDeviceAttached function.
 * TODO: change to correct type. */
pub type amd_device_attached_callback = *mut ::std::ffi::c_void;

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct am_device_notification_callback_info {
    pub dev: *mut am_device,
    pub msg: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_am_device_notification_callback_info() {
    assert_eq!(
        ::std::mem::size_of::<am_device_notification_callback_info>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(am_device_notification_callback_info)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<am_device_notification_callback_info>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(am_device_notification_callback_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_device_notification_callback_info>())).dev as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification_callback_info),
            "::",
            stringify!(dev)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_device_notification_callback_info>())).msg as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification_callback_info),
            "::",
            stringify!(msg)
        )
    );
}
pub type am_restore_device_notification_callback =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut am_recovery_device)>;

/* This is a CoreFoundation object of class AMRecoveryModeDevice. */
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct am_recovery_device {
    pub unknown0: [::std::os::raw::c_uchar; 8usize],
    pub callback: am_restore_device_notification_callback,
    pub user_info: *mut ::std::ffi::c_void,
    pub unknown1: [::std::os::raw::c_uchar; 12usize],
    pub readwrite_pipe: ::std::os::raw::c_uint,
    pub read_pipe: ::std::os::raw::c_uchar,
    pub write_ctrl_pipe: ::std::os::raw::c_uchar,
    pub read_unknown_pipe: ::std::os::raw::c_uchar,
    pub write_file_pipe: ::std::os::raw::c_uchar,
    pub write_input_pipe: ::std::os::raw::c_uchar,
}
#[test]
fn bindgen_test_layout_am_recovery_device() {
    assert_eq!(
        ::std::mem::size_of::<am_recovery_device>(),
        45usize,
        concat!("Size of: ", stringify!(am_recovery_device))
    );
    assert_eq!(
        ::std::mem::align_of::<am_recovery_device>(),
        1usize,
        concat!("Alignment of ", stringify!(am_recovery_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_recovery_device>())).unknown0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(unknown0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_recovery_device>())).callback as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_recovery_device>())).user_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(user_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_recovery_device>())).unknown1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(unknown1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_recovery_device>())).readwrite_pipe as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(readwrite_pipe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_recovery_device>())).read_pipe as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(read_pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_recovery_device>())).write_ctrl_pipe as *const _ as usize
        },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(write_ctrl_pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_recovery_device>())).read_unknown_pipe as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(read_unknown_pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_recovery_device>())).write_file_pipe as *const _ as usize
        },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(write_file_pipe)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_recovery_device>())).write_input_pipe as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(am_recovery_device),
            "::",
            stringify!(write_input_pipe)
        )
    );
}

/* A CoreFoundation object of class AMRestoreModeDevice. */
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct am_restore_device {
    pub unknown: [::std::os::raw::c_uchar; 32usize],
    pub port: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_am_restore_device() {
    assert_eq!(
        ::std::mem::size_of::<am_restore_device>(),
        36usize,
        concat!("Size of: ", stringify!(am_restore_device))
    );
    assert_eq!(
        ::std::mem::align_of::<am_restore_device>(),
        1usize,
        concat!("Alignment of ", stringify!(am_restore_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_restore_device>())).unknown as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_restore_device),
            "::",
            stringify!(unknown)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_restore_device>())).port as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(am_restore_device),
            "::",
            stringify!(port)
        )
    );
}

/// The type of the device notification callback function.
pub type am_device_notification_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut am_device_notification_callback_info,
        arg: *mut ::std::ffi::c_void,
    ),
>;

pub type notify_callback = ::std::option::Option<
    unsafe extern "C" fn(notification: CFStringRef, data: *mut ::std::ffi::c_void),
>;

pub type am_device_install_application_callback = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: CFDictionaryRef,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct am_device {
    /// 0 - zero
    pub unknown0: [::std::os::raw::c_uchar; 16usize],
    /// 16
    pub device_id: ::std::os::raw::c_uint,
    /// 20 - set to AMD_IPHONE_PRODUCT_ID
    pub product_id: ::std::os::raw::c_uint,
    /// 24 - set to AMD_IPHONE_SERIAL
    pub serial: *mut ::std::os::raw::c_char,
    /// 28
    pub unknown1: ::std::os::raw::c_uint,
    /// 32
    pub unknown2: [::std::os::raw::c_uchar; 4usize],
    /// 36
    pub lockdown_conn: ::std::os::raw::c_uint,
    /// 40
    pub unknown3: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_am_device() {
    assert_eq!(
        ::std::mem::size_of::<am_device>(),
        52usize,
        concat!("Size of: ", stringify!(am_device))
    );
    assert_eq!(
        ::std::mem::align_of::<am_device>(),
        1usize,
        concat!("Alignment of ", stringify!(am_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).unknown0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(unknown0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).device_id as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).product_id as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(product_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).serial as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).unknown1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(unknown1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).unknown2 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(unknown2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).lockdown_conn as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(lockdown_conn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device>())).unknown3 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device),
            "::",
            stringify!(unknown3)
        )
    );
}

pub type AMDeviceRef = *mut am_device;

#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct am_device_notification {
    /// 0
    pub unknown0: ::std::os::raw::c_uint,
    /// 4
    pub unknown1: ::std::os::raw::c_uint,
    /// 8
    pub unknown2: ::std::os::raw::c_uint,
    /// 12
    pub callback: am_device_notification_callback,
    /// 16
    pub unknown3: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_am_device_notification() {
    assert_eq!(
        ::std::mem::size_of::<am_device_notification>(),
        24usize,
        concat!("Size of: ", stringify!(am_device_notification))
    );
    assert_eq!(
        ::std::mem::align_of::<am_device_notification>(),
        1usize,
        concat!("Alignment of ", stringify!(am_device_notification))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device_notification>())).unknown0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification),
            "::",
            stringify!(unknown0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device_notification>())).unknown1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification),
            "::",
            stringify!(unknown1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device_notification>())).unknown2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification),
            "::",
            stringify!(unknown2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device_notification>())).callback as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<am_device_notification>())).unknown3 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(am_device_notification),
            "::",
            stringify!(unknown3)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct afc_connection {
    pub handle: ::std::os::raw::c_uint,
    pub unknown0: ::std::os::raw::c_uint,
    pub unknown1: ::std::os::raw::c_uchar,
    pub padding: [::std::os::raw::c_uchar; 3usize],
    pub unknown2: ::std::os::raw::c_uint,
    pub unknown3: ::std::os::raw::c_uint,
    pub unknown4: ::std::os::raw::c_uint,
    /// 24
    pub fs_block_size: ::std::os::raw::c_uint,
    /// 28: always 0x3c
    pub sock_block_size: ::std::os::raw::c_uint,
    /// 32: from AFCConnectionOpen, usu. 0
    pub io_timeout: ::std::os::raw::c_uint,
    /// 36
    pub afc_lock: *mut ::std::ffi::c_void,
    /// 40
    pub context: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_afc_connection() {
    assert_eq!(
        ::std::mem::size_of::<afc_connection>(),
        48usize,
        concat!("Size of: ", stringify!(afc_connection))
    );
    assert_eq!(
        ::std::mem::align_of::<afc_connection>(),
        1usize,
        concat!("Alignment of ", stringify!(afc_connection))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).handle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).unknown0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(unknown0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).unknown1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(unknown1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).padding as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).unknown2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(unknown2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).unknown3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(unknown3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).unknown4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(unknown4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).fs_block_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(fs_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).sock_block_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(sock_block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).io_timeout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(io_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).afc_lock as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(afc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<afc_connection>())).context as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(afc_connection),
            "::",
            stringify!(context)
        )
    );
}
pub type AFCConnectionRef = *mut afc_connection;

#[repr(C, packed)]
#[derive(Debug)]
pub struct afc_directory {
    pub unknown: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[repr(C, packed)]
#[derive(Debug)]
pub struct afc_dictionary {
    pub unknown: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
pub type afc_file_ref = ::std::os::raw::c_ulonglong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct usbmux_listener_1 {
    pub unknown0: ::std::os::raw::c_uint,
    pub unknown1: *mut ::std::os::raw::c_uchar,
    pub callback: amd_device_attached_callback,
    pub unknown3: ::std::os::raw::c_uint,
    pub unknown4: ::std::os::raw::c_uint,
    pub unknown5: ::std::os::raw::c_uint,
}
#[repr(C, packed)]
#[derive(Copy, Clone)]
pub struct usbmux_listener_2 {
    pub unknown0: [::std::os::raw::c_uchar; 4144usize],
}

#[repr(C, packed)]
#[derive(Debug)]
pub struct am_bootloader_control_packet {
    pub opcode: ::std::os::raw::c_uchar,
    pub length: ::std::os::raw::c_uchar,
    pub magic: [::std::os::raw::c_uchar; 2usize],
    pub payload: __IncompleteArrayField<::std::os::raw::c_uchar>,
}
#[test]
fn bindgen_test_layout_am_bootloader_control_packet() {
    assert_eq!(
        ::std::mem::size_of::<am_bootloader_control_packet>(),
        4usize,
        concat!("Size of: ", stringify!(am_bootloader_control_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<am_bootloader_control_packet>(),
        1usize,
        concat!("Alignment of ", stringify!(am_bootloader_control_packet))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_bootloader_control_packet>())).opcode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(am_bootloader_control_packet),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_bootloader_control_packet>())).length as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(am_bootloader_control_packet),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_bootloader_control_packet>())).magic as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(am_bootloader_control_packet),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<am_bootloader_control_packet>())).payload as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(am_bootloader_control_packet),
            "::",
            stringify!(payload)
        )
    );
}
extern "C" {
    pub fn AMDSetLogLevel(level: ::std::os::raw::c_int);

    /// Registers a notification with the current run loop. The callback gets
    /// copied into the notification struct, as well as being registered with the
    /// current run loop. dn_unknown3 gets copied into unknown3 in the same.
    /// (Maybe dn_unknown3 is a user info parameter that gets passed as an arg to
    /// the callback?) unused0 and unused1 are both 0 when iTunes calls this.
    /// In iTunes the callback is located from $3db78e-$3dbbaf.
    ///
    /// ### Returns:
    ///   `MDERR_OK`            if successful
    ///   `MDERR_SYSCALL`       if CFRunLoopAddSource() failed
    ///   `MDERR_OUT_OF_MEMORY` if we ran out of memory
    ///
    pub fn AMDeviceNotificationSubscribe(
        callback: am_device_notification_callback,
        unused0: ::std::os::raw::c_uint,
        unused1: ::std::os::raw::c_uint,
        dn_unknown3: *mut ::std::ffi::c_void,
        notification: *mut *mut am_device_notification,
    ) -> mach_error_t;

    pub fn AMDCreateDeviceList() -> CFArrayRef;

    /// Connects to the iPhone. Pass in the am_device structure that the
    /// notification callback will give to you.
    ///
    /// ### Returns:
    ///   `MDERR_OK`                if successfully connected
    ///   `MDERR_SYSCALL`           if setsockopt() failed
    ///   `MDERR_QUERY_FAILED`      if the daemon query failed
    ///   `MDERR_INVALID_ARGUMENT`  if USBMuxConnectByPort returned 0xffffffff
    ///
    pub fn AMDeviceConnect(device: *mut am_device) -> mach_error_t;

    /// Calls PairingRecordPath() on the given device, than tests whether the path
    /// which that function returns exists. During the initial connect, the path
    /// returned by that function is '/', and so this returns 1.
    ///
    /// ### Returns:
    ///   `0`   if the path did not exist
    ///   `1`   if it did
    ///
    pub fn AMDeviceIsPaired(device: *mut am_device) -> ::std::os::raw::c_int;

    /// iTunes calls this function immediately after testing whether the device is
    /// paired. It creates a pairing file and establishes a Lockdown connection.
    ///
    /// ### Returns:
    ///   `MDERR_OK`                if successful
    ///   `MDERR_INVALID_ARGUMENT`  if the supplied device is null
    ///   `MDERR_DICT_NOT_LOADED`   if the load_dict() call failed
    ///
    pub fn AMDeviceValidatePairing(device: *mut am_device) -> mach_error_t;

    /// Creates a Lockdown session and adjusts the device structure appropriately
    /// to indicate that the session has been started. iTunes calls this function
    /// after validating pairing.
    ///
    /// ### Returns:
    ///   `MDERR_OK`                if successful
    ///   `MDERR_INVALID_ARGUMENT`  if the Lockdown conn has not been established
    ///   `MDERR_DICT_NOT_LOADED`   if the load_dict() call failed
    ///
    pub fn AMDeviceStartSession(device: *mut am_device) -> mach_error_t;

    /// Starts a service and returns a handle that can be used in order to further
    /// access the service. You should stop the session and disconnect before using
    /// the service. iTunes calls this function after starting a session. It starts
    /// the service and the SSL connection. unknown may safely be
    /// NULL (it is when iTunes calls this), but if it is not, then it will be
    /// filled upon function exit. service_name should be one of the AMSVC_*
    /// constants. If the service is AFC (AMSVC_AFC), then the handle is the handle
    /// that will be used for further AFC* calls.
    ///
    /// ### Returns:
    ///    `MDERR_OK`                if successful
    ///    `MDERR_SYSCALL`           if the setsockopt() call failed
    ///    `MDERR_INVALID_ARGUMENT`  if the Lockdown conn has not been established
    ///
    pub fn AMDeviceStartService(
        device: *mut am_device,
        service_name: CFStringRef,
        handle: *mut ServiceConnRef,
        unknown: *mut ::std::os::raw::c_uint,
    ) -> mach_error_t;

    pub fn AMDeviceStartHouseArrestService(
        device: *mut am_device,
        identifier: CFStringRef,
        unknown: *mut ::std::ffi::c_void,
        handle: ServiceConnRef,
        what: *mut ::std::os::raw::c_uint,
    ) -> mach_error_t;

    /// Stops a session. You should do this before accessing services.
    ///
    /// ### Returns:
    ///    `MDERR_OK`                if successful
    ///    `MDERR_INVALID_ARGUMENT`  if the Lockdown conn has not been established
    ///
    pub fn AMDeviceStopSession(device: *mut am_device) -> mach_error_t;

    /// Opens an Apple File Connection. You must start the appropriate service
    /// first with AMDeviceStartService(). In iTunes, io_timeout is 0.
    ///
    /// ### Returns:
    ///    `MDERR_OK`                if successful
    ///    `MDERR_AFC_OUT_OF_MEMORY` if malloc() failed
    ///
    pub fn AFCConnectionOpen(
        handle: ServiceConnRef,
        io_timeout: ::std::os::raw::c_uint,
        conn: *mut AFCConnectionRef,
    ) -> afc_error_t;

    /// Pass in a pointer to an afc_device_info structure. It will be filled.
    pub fn AFCDeviceInfoOpen(conn: AFCConnectionRef, info: *mut *mut afc_dictionary)
        -> afc_error_t;

    /// Turns debug mode on if the environment variable AFCDEBUG is set to a numeric
    /// value, or if the file '/AFCDEBUG' is present and contains a value.
    pub fn AFCPlatformInit();

    /// Opens a directory on the iPhone. Pass in a pointer in dir to be filled in.
    /// Note that this normally only accesses the iTunes sandbox/partition as the
    /// root, which is /var/root/Media. Pathnames are specified with '/' delimiters
    /// as in Unix style.
    ///
    /// ### Returns:
    ///    `MDERR_OK`                if successful
    ///
    pub fn AFCDirectoryOpen(
        conn: AFCConnectionRef,
        path: *const ::std::os::raw::c_char,
        dir: *mut *mut afc_directory,
    ) -> afc_error_t;

    /// Acquires the next entry in a directory previously opened with
    /// AFCDirectoryOpen(). When dirent is filled with a NULL value, then the end
    /// of the directory has been reached. '.' and '..' will be returned as the
    /// first two entries in each directory except the root; you may want to skip
    /// over them.
    ///
    /// ### Returns:
    ///    `MDERR_OK`                if successful, even if no entries remain
    ///
    pub fn AFCDirectoryRead(
        conn: AFCConnectionRef,
        /*unsigned int unused*/
        dir: *mut afc_directory,
        dirent: *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;

    pub fn AFCDirectoryClose(conn: AFCConnectionRef, dir: *mut afc_directory) -> afc_error_t;

    pub fn AFCDirectoryCreate(
        conn: AFCConnectionRef,
        dirname: *const ::std::os::raw::c_char,
    ) -> afc_error_t;

    pub fn AFCRemovePath(
        conn: AFCConnectionRef,
        dirname: *const ::std::os::raw::c_char,
    ) -> afc_error_t;

    pub fn AFCRenamePath(
        conn: AFCConnectionRef,
        from: *const ::std::os::raw::c_char,
        to: *const ::std::os::raw::c_char,
    ) -> afc_error_t;

    pub fn AFCLinkPath(
        conn: AFCConnectionRef,
        linktype: ::std::os::raw::c_longlong,
        target: *const ::std::os::raw::c_char,
        linkname: *const ::std::os::raw::c_char,
    ) -> afc_error_t;

    /// Returns the `context` field of the given AFC connection.
    pub fn AFCConnectionGetContext(conn: AFCConnectionRef) -> ::std::os::raw::c_uint;

    /// Returns the `fs_block_size` field of the given AFC connection.
    pub fn AFCConnectionGetFSBlockSize(conn: AFCConnectionRef) -> ::std::os::raw::c_uint;

    /// Returns the `io_timeout` field of the given AFC connection. In iTunes this is 0.
    pub fn AFCConnectionGetIOTimeout(conn: AFCConnectionRef) -> ::std::os::raw::c_uint;

    /// Returns the `sock_block_size` field of the given AFC connection.
    pub fn AFCConnectionGetSocketBlockSize(conn: AFCConnectionRef) -> ::std::os::raw::c_uint;

    /// Closes the AFC connection.
    pub fn AFCConnectionClose(conn: AFCConnectionRef) -> afc_error_t;

    /// Registers for device notifications related to the restore process. unknown0
    /// is zero when iTunes calls this. In iTunes,
    /// the callbacks are located at:
    ///    1: $3ac68e-$3ac6b1, calls $3ac542(unknown1, arg, 0)
    ///    2: $3ac66a-$3ac68d, calls $3ac542(unknown1, 0, arg)
    ///    3: $3ac762-$3ac785, calls $3ac6b2(unknown1, arg, 0)
    ///    4: $3ac73e-$3ac761, calls $3ac6b2(unknown1, 0, arg)
    ///
    pub fn AMRestoreRegisterForDeviceNotifications(
        dfu_connect_callback: am_restore_device_notification_callback,
        recovery_connect_callback: am_restore_device_notification_callback,
        dfu_disconnect_callback: am_restore_device_notification_callback,
        recovery_disconnect_callback: am_restore_device_notification_callback,
        unknown0: ::std::os::raw::c_uint,
        user_info: *mut ::std::ffi::c_void,
    ) -> ::std::os::raw::c_uint;

    /// Causes the restore functions to spit out (unhelpful) progress messages to
    /// the file specified by the given path. iTunes always calls this right before
    /// restoring with a path of
    /// "$HOME/Library/Logs/iPhone Updater Logs/iPhoneUpdater X.log", where X is an
    /// unused number.
    ///
    pub fn AMRestoreEnableFileLogging(path: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_uint;

    /// Initializes a new option dictionary to default values. Pass the constant
    /// kCFAllocatorDefault as the allocator. The option dictionary looks as
    /// follows:
    /// {
    ///    NORImageType => 'production',
    ///    AutoBootDelay => 0,
    ///    KernelCacheType => 'Release',
    ///    UpdateBaseband => true,
    ///    DFUFileType => 'RELEASE',
    ///    SystemImageType => 'User',
    ///    CreateFilesystemPartitions => true,
    ///    FlashNOR => true,
    ///    RestoreBootArgs => 'rd=md0 nand-enable-reformat=1 -progress'
    ///    BootImageType => 'User'
    /// }
    ///
    /// ### Returns:
    ///    the option dictionary   if successful
    ///    NULL                    if out of memory
    ///
    pub fn AMRestoreCreateDefaultOptions(allocator: CFAllocatorRef) -> CFMutableDictionaryRef;

    /* ----------------------------------------------------------------------------
     *   Less-documented public routines
     * ------------------------------------------------------------------------- */

    /// mode 2 = read, mode 3 = write
    pub fn AFCFileRefOpen(
        conn: AFCConnectionRef,
        path: *const ::std::os::raw::c_char,
        mode: ::std::os::raw::c_ulonglong,
        ref_: *mut afc_file_ref,
    ) -> afc_error_t;

    pub fn AFCFileRefSeek(
        conn: AFCConnectionRef,
        ref_: afc_file_ref,
        offset1: ::std::os::raw::c_ulonglong,
        offset2: ::std::os::raw::c_ulonglong,
    ) -> afc_error_t;

    pub fn AFCFileRefRead(
        conn: AFCConnectionRef,
        ref_: afc_file_ref,
        buf: *mut ::std::ffi::c_void,
        len: *mut usize,
    ) -> afc_error_t;

    pub fn AFCFileRefSetFileSize(
        conn: AFCConnectionRef,
        ref_: afc_file_ref,
        offset: ::std::os::raw::c_ulonglong,
    ) -> afc_error_t;

    pub fn AFCFileRefWrite(
        conn: AFCConnectionRef,
        ref_: afc_file_ref,
        buf: *const ::std::ffi::c_void,
        len: usize,
    ) -> afc_error_t;

    pub fn AFCFileRefClose(conn: AFCConnectionRef, ref_: afc_file_ref) -> afc_error_t;

    pub fn AFCFileInfoOpen(
        conn: AFCConnectionRef,
        path: *const ::std::os::raw::c_char,
        info: *mut *mut afc_dictionary,
    ) -> afc_error_t;

    pub fn AFCKeyValueRead(
        dict: *mut afc_dictionary,
        key: *mut *mut ::std::os::raw::c_char,
        val: *mut *mut ::std::os::raw::c_char,
    ) -> afc_error_t;

    pub fn AFCKeyValueClose(dict: *mut afc_dictionary) -> afc_error_t;

    pub fn AMRestorePerformRecoveryModeRestore(
        rdev: *mut am_recovery_device,
        opts: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        user_info: *mut ::std::ffi::c_void,
    ) -> ::std::os::raw::c_uint;

    pub fn AMRestorePerformRestoreModeRestore(
        rdev: *mut am_restore_device,
        opts: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        user_info: *mut ::std::ffi::c_void,
    ) -> ::std::os::raw::c_uint;

    pub fn AMRestoreModeDeviceCreate(
        unknown0: ::std::os::raw::c_uint,
        connection_id: ::std::os::raw::c_uint,
        unknown1: ::std::os::raw::c_uint,
    ) -> *mut am_restore_device;

    pub fn AMRestoreCreatePathsForBundle(
        restore_bundle_path: CFStringRef,
        kernel_cache_type: CFStringRef,
        boot_image_type: CFStringRef,
        unknown0: ::std::os::raw::c_uint,
        firmware_dir_path: *mut CFStringRef,
        kernelcache_restore_path: *mut CFStringRef,
        unknown1: ::std::os::raw::c_uint,
        ramdisk_path: *mut CFStringRef,
    ) -> ::std::os::raw::c_uint;

    pub fn AMDeviceGetConnectionID(device: *mut am_device) -> ::std::os::raw::c_uint;

    pub fn AMDeviceEnterRecovery(device: *mut am_device) -> mach_error_t;

    pub fn AMDeviceDisconnect(device: *mut am_device) -> mach_error_t;

    pub fn AMDeviceRetain(device: *mut am_device) -> mach_error_t;

    pub fn AMDeviceRelease(device: *mut am_device) -> mach_error_t;

    pub fn AMDeviceCopyValue(
        device: *mut am_device,
        arg1: *mut ::std::ffi::c_void,
        cfstring: CFStringRef,
    ) -> CFStringRef;

    pub fn AMDeviceCopyDeviceIdentifier(device: *mut am_device) -> CFStringRef;

    pub fn AMDPostNotification(
        socket: service_conn_t,
        notification: CFStringRef,
        userinfo: CFStringRef,
    ) -> mach_error_t;

    pub fn AMDObserveNotification(
        socket: *mut ::std::ffi::c_void,
        notification: CFStringRef,
    ) -> mach_error_t;

    pub fn AMDListenForNotifications(
        socket: *mut ::std::ffi::c_void,
        cb: notify_callback,
        data: *mut ::std::ffi::c_void,
    ) -> mach_error_t;

    pub fn AMDShutdownNotificationProxy(socket: *mut ::std::ffi::c_void) -> mach_error_t;

    pub fn AMDeviceDeactivate(device: *mut am_device) -> mach_error_t;

    pub fn AMDeviceActivate(device: *mut am_device, arg1: CFMutableDictionaryRef) -> mach_error_t;

    pub fn AMDeviceSerialize(device: *mut am_device) -> *mut ::std::ffi::c_void;

    pub fn AMDAddLogFileDescriptor(fd: ::std::os::raw::c_int);

    pub fn AMDeviceInstallApplication(
        socket: service_conn_t,
        path: CFStringRef,
        options: CFDictionaryRef,
        callback: am_device_install_application_callback,
        user: *mut ::std::ffi::c_void,
    ) -> mach_error_t;

    pub fn AMDeviceTransferApplication(
        socket: service_conn_t,
        path: CFStringRef,
        options: CFDictionaryRef,
        callbackj: am_device_install_application_callback,
        user: *mut ::std::ffi::c_void,
    ) -> mach_error_t;

    pub fn AMDeviceSecureUninstallApplication(
        unknown0: ::std::os::raw::c_int,
        device: *mut am_device,
        bundle_id: CFStringRef,
        unknown1: ::std::os::raw::c_int,
        callback: *mut ::std::ffi::c_void,
        callback_arg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn AMDeviceSecureStartService(
        device: AMDeviceRef,
        service_name: CFStringRef,
        unknown: *mut ::std::os::raw::c_uint,
        handle: *mut ServiceConnRef,
    ) -> mach_error_t;

    pub fn AMDeviceCreateHouseArrestService(
        device: AMDeviceRef,
        identifier: CFStringRef,
        options: CFDictionaryRef,
        handle: *mut AFCConnectionRef,
    ) -> mach_error_t;

    pub fn AMDServiceConnectionGetSocket(con: ServiceConnRef) -> CFSocketNativeHandle;

    pub fn AMDServiceConnectionInvalidate(con: ServiceConnRef);

    pub fn AMDeviceIsAtLeastVersionOnPlatform(device: AMDeviceRef, vers: CFDictionaryRef) -> bool;

    pub fn AMDeviceSecureTransferPath(
        zero: ::std::os::raw::c_int,
        device: AMDeviceRef,
        url: CFURLRef,
        options: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        cbarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn AMDeviceSecureInstallApplication(
        zero: ::std::os::raw::c_int,
        device: AMDeviceRef,
        url: CFURLRef,
        options: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        cbarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub fn AMDeviceSecureInstallApplicationBundle(
        device: AMDeviceRef,
        url: CFURLRef,
        options: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        cbarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    /* ----------------------------------------------------------------------------
     *   Semi-private routines
     * ------------------------------------------------------------------------- */

    /// Pass in a usbmux_listener_1 structure and a usbmux_listener_2 structure
    /// pointer, which will be filled with the resulting usbmux_listener_2.
    ///
    /// ### Returns:
    ///   `MDERR_OK`                if completed successfully
    ///   `MDERR_USBMUX_ARG_NULL`   if one of the arguments was NULL
    ///   `MDERR_USBMUX_FAILED`     if the listener was not created successfully
    ///
    pub(crate) fn USBMuxListenerCreate(
        esi_fp8: *mut usbmux_listener_1,
        eax_fp12: *mut *mut usbmux_listener_2,
    ) -> usbmux_error_t;

    /* ----------------------------------------------------------------------------
     *   Less-documented semi-private routines
     * ------------------------------------------------------------------------- */

    pub(crate) fn USBMuxListenerHandleData(arg1: *mut ::std::ffi::c_void) -> usbmux_error_t;

    /* ----------------------------------------------------------------------------
     *   Private routines - here be dragons
     * ------------------------------------------------------------------------- */

    /* AMRestorePerformRestoreModeRestore() calls this function with a dictionary
     * in order to perform certain special restore operations
     * (RESTORED_OPERATION_*). It is thought that this function might enable
     * significant access to the phone. */

    /*
    typedef unsigned int (*t_performOperation)(struct am_restore_device *rdev,
        CFDictionaryRef op); // __attribute__ ((regparm(2)));
    */

    pub(crate) fn AMDeviceMountImage(
        device: AMDeviceRef,
        image: CFStringRef,
        options: CFDictionaryRef,
        callback: *mut ::std::ffi::c_void,
        cbarg: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;

    pub(crate) fn AMDeviceLookupApplications(
        device: AMDeviceRef,
        options: CFDictionaryRef,
        result: *mut CFMutableDictionaryRef,
    ) -> mach_error_t;

    pub(crate) fn AMDeviceGetInterfaceType(device: AMDeviceRef) -> ::std::os::raw::c_int;

    pub(crate) fn AMDServiceConnectionSend(
        con: ServiceConnRef,
        data: *const ::std::ffi::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;

    pub(crate) fn AMDServiceConnectionReceive(
        con: ServiceConnRef,
        data: *mut ::std::ffi::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;

}
